  // server.js
  require('dotenv').config();
  const express = require('express');
  const cors = require('cors');
  const { PromisePool } = require('@supercharge/promise-pool');
  const { searchBusiness } = require('./enrich');
  const store = require('./store');
  const { exportCSV } = require('./csv-exporter');
  const { scrapeSalonDetails } = require('./scraper');

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  async function healthCheck() {
    return {
      status: 'OK',
      timestamp: new Date().toISOString(),
      isProcessing: isProcessing,
      dataCount: store.getAll().length,
      memory: process.memoryUsage(),
      uptime: process.uptime()
    };
  }

  const app = express();
  app.use(cors());
  app.use(express.json({ limit: '10mb' }));

  let isProcessing = false;
  let scrapeController = new AbortController();

  // Health check endpoint
  app.get('/health', async (req, res) => {
    try {
      const health = await healthCheck();
      res.json(health);
    } catch (error) {
      res.status(500).json({ status: 'ERROR', error: error.message });
    }
  });

  app.post('/start', async (req, res) => {
    const { 
      baseURL, 
      maxProcess = parseInt(process.env.MAX_PROCESS) || 5,
      startPage = 1,
      endPage = null,
      limitPerPage = 10
    } = req.body;    
    const concurrency = parseInt(process.env.ENRICHMENT_CONCURRENCY) || 8;
    const startTime = Date.now();

    console.log('\n' + '='.repeat(80));
    console.log('üöÄ STARTING NEW SCRAPING & ENRICHMENT PROCESS');
    console.log('='.repeat(80));
    console.log(`üìä Configuration:`);
    console.log(`   üéØ Target URL: ${baseURL}`);
    console.log(`   üìà Max Process: ${maxProcess}`);
    console.log(`   üìÑ Page Range: ${startPage} to ${endPage || 'auto-detect'}`);
    console.log(`   üî¢ Limit per Page: ${limitPerPage}`);
    console.log(`   ‚ö° Concurrency: ${concurrency}`);
    console.log(`   üïê Start Time: ${new Date().toLocaleString()}`);
    console.log('='.repeat(80));

    if (isProcessing) {
      console.log('‚ùå REQUEST REJECTED: Processing already in progress');
      return res.status(429).json({ error: 'Processing already in progress' });
    }

    if (!baseURL) {
      console.log('‚ùå REQUEST REJECTED: Missing baseURL');
      return res.status(400).json({ error: 'Missing baseURL in request body' });
    }

    // Validate page range
    if (startPage < 1) {
      console.log('‚ùå REQUEST REJECTED: Start page must be >= 1');
      return res.status(400).json({ error: 'Start page must be >= 1' });
    }

    if (endPage && endPage < startPage) {
      console.log('‚ùå REQUEST REJECTED: End page must be >= start page');
      return res.status(400).json({ error: 'End page must be >= start page' });
    }

    if (limitPerPage < 1 || limitPerPage > 100) {
      console.log('‚ùå REQUEST REJECTED: Limit per page must be between 1 and 100');
      return res.status(400).json({ error: 'Limit per page must be between 1 and 100' });
    }

    isProcessing = true;
    store.clear();
    scrapeController = new AbortController();

    res.writeHead(200, {
      'Content-Type': 'application/json',
      'Transfer-Encoding': 'chunked'
    });

      let processedCount = 0;
  let enrichedCount = 0;
  let failedCount = 0;
  let skippedCount = 0;
  const businesses = [];
  let scrapingEndTime;

    try {
      // First, collect businesses from scraping
      console.log('\nüì• PHASE 1: SCRAPING BUSINESSES');
      console.log('-'.repeat(50));
      const scrapingStartTime = Date.now();
      const scrapingStream = scrapeSalonDetails(
        scrapeController.signal, 
        baseURL, 
        { startPage, endPage, limitPerPage }
      );
      
      let scrapedCount = 0;
      for await (const business of scrapingStream) {
        if (scrapeController.signal.aborted) {
          console.log('‚ùå Scraping aborted by user');
          break;
        }
        
        scrapedCount++;
        businesses.push(business);
        console.log(`üìã [${scrapedCount}] Scraped: "${business.name}" | ${business.address} | Page: ${business.page || 'N/A'}`);
        
        // Stop collecting when we have enough to process
        if (businesses.length >= maxProcess * 2) { // Buffer to account for failures
          console.log(`‚úÖ Reached buffer limit (${businesses.length} businesses), starting enrichment...`);
          break;
        }
      }

      scrapingEndTime = Date.now();
      const scrapingDuration = (scrapingEndTime - scrapingStartTime) / 1000;
      
      console.log('\nüìä SCRAPING PHASE COMPLETED');
      console.log('-'.repeat(50));
      console.log(`‚úÖ Total scraped: ${businesses.length} businesses`);
      console.log(`üìÑ Pages processed: ${startPage} to ${Math.min(endPage || startPage, Math.max(...businesses.map(b => b.page || 1)))}`);
      console.log(`‚è±Ô∏è  Duration: ${scrapingDuration}s`);
      console.log(`üìà Rate: ${(businesses.length / scrapingDuration).toFixed(2)} businesses/second`);

      // Send scraping completion update
      res.write(JSON.stringify({
        phase: 'scraping_completed',
        scraped_count: businesses.length,
        scraping_duration: scrapingDuration,
        pages_processed: Math.max(...businesses.map(b => b.page || 1)) - startPage + 1,
        starting_enrichment: true
      }) + '\n');

      // Process businesses with higher concurrency and better error handling
      console.log('\nüîÑ PHASE 2: ENRICHMENT PROCESSING');
      console.log('-'.repeat(50));
      console.log(`üéØ Target to process: ${maxProcess} businesses`);
      console.log(`‚ö° Concurrency level: ${concurrency}`);
      console.log(`üìä Available businesses: ${businesses.length}`);
      
      const enrichmentStartTime = Date.now();
      let completedEnrichments = 0;
      
      await PromisePool
        .withConcurrency(concurrency) // Configurable concurrency
        .for(businesses)
        .handleError(async (error, business) => {
          completedEnrichments++;
          console.error(`\n‚ùå [ERROR ${completedEnrichments}/${maxProcess}] Pipeline error for "${business?.name}":`, error.message);
          
          const errorRecord = {
            id: ++processedCount,
            ...business,
            error: error.message,
            enrichment_status: 'failed'
          };
          
          store.add(errorRecord);
          failedCount++;
          
          console.log(`üìä Progress: ${processedCount}/${maxProcess} | ‚úÖ ${enrichedCount} | ‚ùå ${failedCount}`);
          
          // Send failure notification but continue processing
          try {
            res.write(JSON.stringify({
              id: errorRecord.id,
              name: errorRecord.name,
              status: 'failed',
              error: error.message,
              progress: `${processedCount}/${maxProcess}`,
              phase: 'enrichment'
            }) + '\n');
          } catch (writeError) {
            console.error('Write error:', writeError);
          }
          
          return { shouldCollect: true }; // Continue processing
        })
        .process(async (business) => {
          // Stop if we've processed enough OR if manually cancelled
          if (processedCount >= maxProcess || scrapeController.signal.aborted) {
            if (scrapeController.signal.aborted) {
              console.log(`‚ùå Processing stopped - user cancelled at ${processedCount}/${maxProcess}`);
            }
            return;
          }

          console.log(`\nüîÑ [${processedCount + 1}/${maxProcess}] Starting enrichment: "${business.name}"`);

          try {
            const enrichmentStartTime = Date.now();
            const info = await searchBusiness(business.name, business.address);
            const enrichmentDuration = (Date.now() - enrichmentStartTime) / 1000;
            
            const record = {
              id: ++processedCount,
              ...business,
              ...info,
              enrichment_status: info.error ? 'failed' : 'success'
            };

            // Validate that business has essential contact information
            const hasContactInfo = record.owner || record.email || record.phone;
            
            if (!hasContactInfo && !info.error) {
              skippedCount++;
              console.log(`‚ö†Ô∏è [${processedCount}/${maxProcess}] Skipping "${business.name}" - no contact information found`);
              console.log(`   üë§ Owner: ${record.owner || 'None'}`);
              console.log(`   üìß Email: ${record.email || 'None'}`);
              console.log(`   üìû Phone: ${record.phone || 'None'}`);
              console.log(`üìä Current Stats: ‚úÖ ${enrichedCount} enriched | ‚ùå ${failedCount} failed | ‚è≠Ô∏è ${skippedCount} skipped`);
              
              // Don't store this record, but continue processing
              processedCount--; // Decrement since we're not counting this one
              
              // Send skip notification
              try {
                res.write(JSON.stringify({
                  name: record.name,
                  status: 'skipped',
                  reason: 'No contact information found',
                  progress: `${processedCount}/${maxProcess}`,
                  enriched: enrichedCount,
                  failed: failedCount,
                  skipped: skippedCount,
                  phase: 'enrichment'
                }) + '\n');
              } catch (writeError) {
                console.error('Write error:', writeError);
              }
              
              return; // Skip to next business (use return instead of continue)
            }

            store.add(record);
            
            if (info.error) {
              failedCount++;
              console.log(`‚ùå [${processedCount}/${maxProcess}] Enrichment failed for "${business.name}" (${enrichmentDuration}s): ${info.error}`);
            } else {
              enrichedCount++;
              console.log(`‚úÖ [${processedCount}/${maxProcess}] Enrichment successful for "${business.name}" (${enrichmentDuration}s)`);
              if (record.owner) console.log(`   üë§ Owner found: ${record.owner}`);
              if (record.email) console.log(`   üìß Email found: ${record.email}`);
              if (record.phone) console.log(`   üìû Phone found: ${record.phone}`);
            }

            console.log(`üìä Current Progress: ${processedCount}/${maxProcess} | ‚úÖ ${enrichedCount} successful | ‚ùå ${failedCount} failed | ‚è≠Ô∏è ${skippedCount} skipped`);

            // Send progress update
            try {
              res.write(JSON.stringify({
                id: record.id,
                name: record.name,
                status: info.error ? 'failed' : 'enriched',
                owner: record.owner || null,
                email: record.email || null,
                phone: record.phone || null,
                verified: record.verified || false,
                progress: `${processedCount}/${maxProcess}`,
                enriched: enrichedCount,
                failed: failedCount,
                skipped: skippedCount,
                phase: 'enrichment'
              }) + '\n');
            } catch (writeError) {
              console.error('Write error:', writeError);
            }

          } catch (error) {
            console.error(`‚ùå [${processedCount + 1}/${maxProcess}] Enrichment error for "${business.name}":`, error);
            
            const errorRecord = {
              id: ++processedCount,
              ...business,
              error: error.message,
              enrichment_status: 'failed'
            };
            
            store.add(errorRecord);
            failedCount++;
            
            console.log(`üìä Progress: ${processedCount}/${maxProcess} | ‚úÖ ${enrichedCount} | ‚ùå ${failedCount} | ‚è≠Ô∏è ${skippedCount}`);
            
            try {
              res.write(JSON.stringify({
                id: errorRecord.id,
                name: errorRecord.name,
                status: 'failed',
                error: error.message,
                progress: `${processedCount}/${maxProcess}`,
                enriched: enrichedCount,
                failed: failedCount,
                skipped: skippedCount,
                phase: 'enrichment'
              }) + '\n');
            } catch (writeError) {
              console.error('Write error:', writeError);
            }
          }
        });

      const endTime = Date.now();
      const totalDuration = (endTime - startTime) / 1000;
      const enrichmentDuration = (endTime - enrichmentStartTime) / 1000;

      // Send completion summary with performance metrics
      console.log('\n' + '='.repeat(80));
      console.log('üéâ PROCESSING COMPLETED SUCCESSFULLY');
      console.log('='.repeat(80));
      console.log(`üìä Final Results:`);
      console.log(`   üéØ Target: ${maxProcess} businesses`);
      console.log(`   ‚úÖ Successfully enriched: ${enrichedCount}`);
      console.log(`   ‚ùå Failed enrichments: ${failedCount}`);
      console.log(`   ‚è≠Ô∏è Skipped (no contact info): ${skippedCount}`);
      console.log(`   üìà Total processed: ${processedCount}`);
      console.log(`   üìã Total scraped: ${businesses.length}`);
      console.log(`   üìà Success rate: ${((enrichedCount / processedCount) * 100).toFixed(1)}%`);
      console.log(`\n‚è±Ô∏è  Performance Metrics:`);
      console.log(`   üïê Total duration: ${totalDuration}s`);
      console.log(`   üì• Scraping time: ${scrapingDuration}s`);
      console.log(`   üîÑ Enrichment time: ${enrichmentDuration}s`);
      console.log(`   ‚ö° Average enrichment: ${(enrichmentDuration / processedCount).toFixed(2)}s per item`);
      console.log(`   üìà Processing rate: ${(processedCount / totalDuration).toFixed(2)} items/second`);
      console.log(`   üèÅ Completion time: ${new Date().toLocaleString()}`);
      console.log('='.repeat(80));

      const summary = {
        status: 'completed',
        total_processed: processedCount,
        enriched: enrichedCount,
        failed: failedCount,
        skipped: skippedCount,
        scraped_businesses: businesses.length,
        performance: {
          total_duration: totalDuration,
          scraping_duration: scrapingDuration,
          enrichment_duration: enrichmentDuration,
          avg_enrichment_time: enrichmentDuration / processedCount,
          concurrency_used: concurrency,
          items_per_second: processedCount / totalDuration
        }
      };
      
      res.end(JSON.stringify(summary));
      
    } catch (error) {
      const errorDuration = (Date.now() - startTime) / 1000;
      console.error('\n' + '='.repeat(80));
      console.error('‚ùå PROCESSING FAILED');
      console.error('='.repeat(80));
      console.error(`üí• Error: ${error.message}`);
      console.error(`‚è±Ô∏è  Duration before failure: ${errorDuration}s`);
      console.error(`üìä Processed before failure: ${processedCount}/${maxProcess}`);
      console.error(`‚úÖ Successful before failure: ${enrichedCount}`);
      console.error(`‚ùå Failed before failure: ${failedCount}`);
      console.error(`‚è≠Ô∏è Skipped before failure: ${skippedCount}`);
      console.error('='.repeat(80));
      
      res.end(JSON.stringify({ 
        status: 'failed', 
        error: error.message,
        processed: processedCount,
        enriched: enrichedCount,
        failed: failedCount,
        skipped: skippedCount,
        duration: errorDuration
      }));
    } finally {
      isProcessing = false;
      console.log('\nüîí Processing flag reset. Ready for next request.\n');
    }
  });

  app.post('/cancel', (req, res) => {
    console.log('\nüõë CANCELLATION REQUEST RECEIVED');
    console.log(`‚è±Ô∏è  Time: ${new Date().toLocaleString()}`);
    console.log(`üìä Was processing: ${isProcessing}`);
    
    if (isProcessing) {
      scrapeController.abort();
      isProcessing = false;
      console.log('‚úÖ Processing cancelled successfully');
      console.log('üîí Processing flag reset');
    } else {
      console.log('‚ö†Ô∏è  No active processing to cancel');
    }
    
    res.json({ status: 'cancelled' });
  });

  app.get('/data', (req, res) => {
    const data = store.getAll();
    console.log(`üìä Data request: Returning ${data.length} records`);
    res.json(data);
  });

  // Debug endpoint to test individual business enrichment
  app.post('/debug-enrich', async (req, res) => {
    const { businessName, address, website } = req.body;
    
    console.log(`üîç [DEBUG] Testing enrichment for: "${businessName}"`);
    console.log(`üìç [DEBUG] Address: ${address}`);
    console.log(`üåê [DEBUG] Website: ${website || 'Not provided'}`);
    
    try {
      const result = await searchBusiness(businessName, address);
      console.log(`üìã [DEBUG] Enrichment result:`, JSON.stringify(result, null, 2));
      
      res.json({
        status: 'success',
        input: { businessName, address, website },
        result: result,
        summary: {
          found_owner: !!result.owner,
          found_email: !!result.email,
          found_phone: !!result.phone,
          found_website: !!result.website,
          data_sources: result.data_sources || {}
        }
      });
    } catch (error) {
      console.error(`‚ùå [DEBUG] Enrichment failed:`, error);
      res.status(500).json({
        status: 'error',
        error: error.message,
        input: { businessName, address, website }
      });
    }
  });

  app.get('/export', (req, res) => {
    const data = store.getAll();
    console.log(`üìÅ Export request: Exporting ${data.length} records to CSV`);
    exportCSV(res);
  });

  // Proxy status endpoint
  app.get('/proxy-status', (req, res) => {
    const { getProxyConfig } = require('./enrich');
    res.json(getProxyConfig());
  });

  const PORT = process.env.PORT;

  console.log('\n' + '='.repeat(80));
  console.log('üöÄ SCRAPER & ENRICHMENT SERVER STARTING');
  console.log('='.repeat(80));
  console.log(`üåê Server Configuration:`);
  console.log(`   üì° Port: ${PORT}`);
  console.log(`   üéØ Max Process: ${process.env.MAX_PROCESS || '500 (default)'}`);
  console.log(`   ‚ö° Enrichment Concurrency: ${process.env.ENRICHMENT_CONCURRENCY || '8 (default)'}`);
  console.log(`   üîë Apify Token: ${process.env.APIFY_TOKEN ? '‚úÖ Configured' : '‚ùå Missing'}`);
  console.log(`   üïê Start Time: ${new Date().toLocaleString()}`);
  console.log(`   üìä Node Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log('='.repeat(80));

  app.listen(PORT, () => {
    console.log(`‚úÖ Server successfully started on PORT ${PORT}`);
    console.log(`üîó Health Check: http://localhost:${PORT}/health`);
    console.log(`üìä API Endpoints:`);
    console.log(`   POST /start - Start scraping & enrichment`);
    console.log(`   POST /cancel - Cancel current processing`);
    console.log(`   GET /data - Get current data`);
    console.log(`   GET /export - Export data as CSV`);
    console.log(`   GET /health - Health check`);
    console.log(`   GET /proxy-status - Proxy status`);
    console.log('\nüéØ Ready to accept requests!\n');
  });